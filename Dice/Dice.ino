
/* Electronic Dice:
 *  
 *  Author: Dustin Westaby
 *  Date: June 1, 2021
 *  
 *  Sources:
 *   - 2017 Joe Coburn (joecoburn) https://www.makeuseof.com/tag/roll-style-diy-electronic-d20/
 *   - 2018 Tomas Carlsson (TomasC62) https://www.instructables.com/Arduino-Oled-Dice/
 *   - 2021 Fernando Hernandez (Dsk001) https://www.prusaprinters.org/prints/66933-electronic-dice
 *   - 2021 Josh Segatto (alienslacker / alieneila) https://twitter.com/alienslacker/status/1398511306546765828
 *  
 *  Wiring:
 *  D2(SDA), D1(SCL) to OLED
 *  D0 to RST
 *  D3 to Button (ROLL) to Ground
 *  D4 to Button (DIE) to 3.3V
 *  D5 to Tilt Sensor to Ground
 *  RX to Tilt Sensor to Ground
 *  D6 to Button LED (ROLL) to Ground
 *  D8 to Button LED (DIE) to Ground
 *  D7 to Neo Pixel Data
 *  
 *  Update the logo_bmp with your own image using LCDAssistant
 *  
 *  If you are not using a battery, comment out #define USE_BATTERY
 *  If you are not using a neopixel strip, comment out #define USE_NEOPIXELS
 *  
 *  Usage:
 *  Press ROLL button to roll dice.
 *  Shake tilt sensors to roll dice.
 *  Hold ROLL button to disable tilt sensors.
 *  Press DICE button to change dice.
 *  Hold DICE button to check battery info.
 *  
 */

 
/* ************************************************* */

/* These are some top level options without touching main code */

//#define USE_BATTERY
//#define USE_NEOPIXELS

#define NUMBER_OF_NEOPIXELS 20
#define TYPE_OF_NEOPIXELS (NEO_GRB + NEO_KHZ800)

#define HOW_FAST_BUTTONS_AND_SCREEN_ARE_PROCESSED_IN_MS    100 // 100 = 10 Hz
#define DEEP_SLEEP_AFTER_THIS_MANY_MS_OF_INACTIVITY     900000 // 900,000 = 15 * 60 * 1000 = 15 mins

/* ************************************************* */

#include "Arduino.h"
#include <ESP8266WiFi.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#ifdef USE_NEOPIXELS
#include <Adafruit_NeoPixel.h>
#endif

//Not all pins are interchangable, refer to https://randomnerdtutorials.com/esp8266-pinout-reference-gpios/
#define DEEP_SLEEP_EXIT_PIN 16 // D0 - Wire to RST
#define DISPLAY_SCL_PIN      5 // D1 - I2C
#define DISPLAY_SDA_PIN      4 // D2 - I2C
#define ROLL_BUTTON_PIN      0 // D3 - Active Low Input
#define DIE_BUTTON_PIN       2 // D4 - Active High Input
#define TILT_SENSOR_1_PIN   14 // D5 - Active High Interrupt
#define ROLL_LED_PIN        12 // D6 - Active High Output
#define NEOPIXEL_DATA_PIN   13 // D7 - Data Output
#define DICE_LED_PIN        15 // D8 - Active High Output
#define TILT_SENSOR_2_PIN    3 // RX - Active High Interrupt
#define BATTERY_MONITOR_PIN A0 // A0 - Analog Input

//screen config
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
// The pins for I2C are defined by the Wire-library. 
// On an arduino UNO:       A4(SDA), A5(SCL)
// On an arduino MEGA 2560: 20(SDA), 21(SCL)
// On an arduino LEONARDO:   2(SDA),  3(SCL),
// On a D1 Mini:             D2(SDA), D1(SCL)
#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define LOGO_HEIGHT 43 //64
#define LOGO_WIDTH 128 //82
static const unsigned char PROGMEM logo_bmp[] =
{ //output from LCDAssistant, byte orientation: Horizontal
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x00,0x00,0x07,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x40,0x01,0xFF,0x00,0x00,0x07,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x38,0x39,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF1,0xFC,0x03,0x39,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF1,0xFE,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x9F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xF8,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x1C,0x03,0x0F,0xFF,0x00,0xFC,0x1F,0xFF,0xE0,0x1C,0x00,0xFE,0x00,0xC0,0x06,0x60,0x1C,0x03,0x0F,0xFF,0x03,0xCF,0x1F,0xFF,0xE0,0x1C,0x00,0xFF,0xE0,0x60,0x0E,0x60,0x1C,0x03,0x0C,0x00,0x06,0x01,0x00,0x30,0x00,0x3C,0x00,0xC0,0x70,0x30,0x0C,0x60,0x34,0x06,0x0C,0x00,0x06,0x00,0x00,0x30,0x00,0x36,0x00,0xC0,0x30,0x30,0x18,0x30,0x36,0x06,0x0C,0x00,0x0C,0x00,0x00,0x30,0x00,0x26,0x00,0xC0,0x18,0x18,0x30,0x30,0x26,0x06,0x0C,0x00,0x0C,0x00,0x00,0x30,0x00,0x63,0x00,0xC0,0x18,0x0C,0x30,0x30,0x22,0x06,0x0C,0x00,0x0E,0x00,0x00,0x30,0x00,0x63,0x00,0xC0,0x30,0x0C,0x60,0x30,0x62,0x0C,0x0C,0x00,0x07,0x00,0x00,0x30,0x00,0xC1,0x00,0xC0,0x30,0x06,0xC0,0x18,0x63,0x0C,0x0F,0xFF,0x03,0xE0,0x00,0x30,0x00,0xC1,0x80,0xFF,0xC0,0x03,0xC0,0x18,0x43,0x0C,0x0F,0xFF,0x01,0xFE,0x00,0x30,0x00,0x81,0x80,0xFF,0xC0,0x03,0x80,0x18,0x41,0x0C,0x0C,0x00,0x00,0x0F,0x00,0x30,0x01,0x80,0x80,0xC0,0x30,0x01,0x80,0x18,0xC1,0x18,0x0C,0x00,0x00,0x03,0x80,0x30,0x01,0x80,0xC0,0xC0,0x18,0x01,0x80,0x0C,0xC1,0x98,0x0C,0x00,0x00,0x01,0x80,0x30,0x03,0x00,0xC0,0xC0,0x18,0x01,0x80,0x0C,0x81,0x98,0x0C,0x00,0x00,0x01,0x80,0x30,0x03,0xFF,0xE0,0xC0,0x18,0x01,0x80,0x0C,0x80,0x98,0x0C,0x00,0x00,0x01,0x80,0x30,0x03,0x00,0x60,0xC0,0x18,0x01,0x80,0x0D,0x80,0x90,0x0C,0x00,0x00,0x01,0x80,0x30,0x06,0x00,0x20,0xC0,0x18,0x01,0x80,0x07,0x80,0xF0,0x0C,0x00,0x08,0x03,0x80,0x30,0x06,0x00,0x30,0xC0,0x38,0x01,0x80,0x07,0x00,0xF0,0x0F,0xFF,0x0F,0x07,0x00,0x30,0x0C,0x00,0x30,0xFF,0xF0,0x01,0x80,0x07,0x00,0x70,0x0F,0xFF,0x03,0xFC,0x00,0x30,0x0C,0x00,0x18,0xFF,0xC0,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

#ifdef USE_NEOPIXELS
Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUMBER_OF_NEOPIXELS, NEOPIXEL_DATA_PIN, TYPE_OF_NEOPIXELS);
int started = 0;
#endif

//variables
int curDie = 6; //Variable to select which die to use
int die[] = {2, 4, 6, 8, 10, 12, 20, 7};

#define BUTTON_HOLD_DELAY_IN_MILLIS_UNTIL_HELD_ACTION 2000

//button routines
//TBD, convert these to typedef enum
enum
{
   PROCESSED,
   NOT_PROCESSED
};

enum
{
  IS_NOT_PRESSED,
  IS_PRESSED,
  WAS_RELEASED,
  IS_HELD,
};

enum
{
  ACTIVE_HIGH,
  ACTIVE_LOW,
  ANALOG_THRESHOLD,
};

enum
{
  ROLL_BUTTON       = 0, //order of array
  DIE_SELECT_BUTTON,
  TILT_INPUT_1,
  TILT_INPUT_2,
  NUMBER_OF_BUTTONS , //keep at end of list
};

//TBD, convert this to a struct def
byte button_pins               [NUMBER_OF_BUTTONS] = { ROLL_BUTTON_PIN, DIE_BUTTON_PIN, TILT_SENSOR_1_PIN, TILT_SENSOR_2_PIN };
byte button_types              [NUMBER_OF_BUTTONS] = { ACTIVE_LOW,      ACTIVE_HIGH,    ACTIVE_HIGH,       ACTIVE_HIGH};
byte button_state              [NUMBER_OF_BUTTONS] = { IS_NOT_PRESSED,  IS_NOT_PRESSED, IS_NOT_PRESSED,    IS_NOT_PRESSED };
byte last_mode_button_state    [NUMBER_OF_BUTTONS] = { NOT_PROCESSED,   NOT_PROCESSED,  NOT_PROCESSED,     NOT_PROCESSED};
long last_interaction_timestamp[NUMBER_OF_BUTTONS] = { 0,               0,              0,                 0};
byte last_button_read          [NUMBER_OF_BUTTONS] = { false,           false,          false,             false};
byte current_button_read       [NUMBER_OF_BUTTONS] = { false,           false,          false,             false};

byte roll_flag = false;
byte tilt_flag = false;
byte tilt_enabled = true;

byte activity_flag = true;

#ifndef USE_BATTERY
ADC_MODE(ADC_VCC);
#endif

void setup() 
{
  //setup output to serial monitor
  Serial.begin(115200);

#ifdef USE_NEOPIXELS
  strip.begin();
  strip.setBrightness(50);
  strip.show(); // Initialize all pixels to 'off'
#endif

  Serial.println(F("Digital Dice v1.0"));

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if(!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("Display driver failed"));
    for(;;); // Don't proceed, loop forever
  }

  // Clear the display buffer
  display.clearDisplay();

  //attempt to fix the RNG
  randomSeed(ESP.getCycleCount());

  // initialize the button pins as an input:
  for(byte i=0; i < NUMBER_OF_BUTTONS; i++)
  {
    pinMode(button_pins[i], INPUT_PULLUP);
  }
  pinMode(button_pins[DIE_SELECT_BUTTON], INPUT); //special pin, Active = 3.3V
#ifndef USE_BATTERY
  pinMode(BATTERY_MONITOR_PIN, INPUT); //battery monitor, add solder jumper to J2 on the v1.2.0 battery shield. See https://arduinodiy.wordpress.com/2016/12/25/monitoring-lipo-battery-voltage-with-wemos-d1-minibattery-shield-and-thingspeak/
#endif

  pinMode(ROLL_LED_PIN, OUTPUT);
  pinMode(DICE_LED_PIN, OUTPUT);
  digitalWrite(ROLL_LED_PIN, HIGH);
  digitalWrite(DICE_LED_PIN, HIGH);

  display.fillScreen(BLACK); // erase the whole display
  display.drawBitmap((SCREEN_WIDTH - LOGO_WIDTH) / 2, (SCREEN_HEIGHT - LOGO_HEIGHT) / 2, logo_bmp, LOGO_WIDTH, LOGO_HEIGHT, 1);
  display.display();
  delay(2000);
  
  display.fillScreen(BLACK);
  drawCurDie();
  drawDie();
  display.display();

  //start die rollers
  attachInterrupt(digitalPinToInterrupt(TILT_SENSOR_1_PIN), handle_tilt_interrupt, CHANGE);
  attachInterrupt(digitalPinToInterrupt(TILT_SENSOR_2_PIN), handle_tilt_interrupt, CHANGE);

  WiFi.mode(WIFI_OFF); //We spend most of our time in light sleep with the radio off
  
  Serial.println(F("Startup Complete."));
}

void loop() 
{

#ifdef USE_NEOPIXELS
  if ( started == 0 ) {
    colorWipe(strip.Color(0, 255, 0), 50); // Green
    started++;
  }
#endif

  //button and LED stuff
  poll_input_signals();
  process_button_presses();
  process_led_state();

  //roll the dice when requested
  if (roll_flag || (tilt_flag && tilt_enabled))
  {
    Serial.println("Interrupt Tilt");
    process_roll_request();
    roll_flag = false;
    tilt_flag = false;
  }

  //power savings
  //check for activity timeout, then light sleep until the next poll interval
  check_for_inactivity_then_power_down();
  sleep_for_poll_rate();
  
} //end loop

void callback() {
  Serial.flush();
}

void setup_text_to_display(int text_color, int text_size, int cursor_x, int cursor_y)
{
    display.setTextColor(text_color);
    display.setTextSize(text_size);
    display.setCursor(cursor_x,cursor_y);
}

void check_for_inactivity_then_power_down()
{
  static long last_activity = 0;

  if (activity_flag)
  {
    activity_flag = false;
    last_activity = millis();
  }

  if(millis() >= (last_activity + DEEP_SLEEP_AFTER_THIS_MANY_MS_OF_INACTIVITY - 10000))
  {
    digitalWrite(ROLL_LED_PIN, LOW);
    digitalWrite(DICE_LED_PIN, LOW);
    
    long seconds = ( (last_activity + DEEP_SLEEP_AFTER_THIS_MANY_MS_OF_INACTIVITY) - millis() ) / 1000;

    Serial.printf("Inactive for %ld minutes. Shutting down in %ld seconds.\n", DEEP_SLEEP_AFTER_THIS_MANY_MS_OF_INACTIVITY/60000, seconds/1000);
    
    display.fillScreen(BLACK); // erase the whole display
    setup_text_to_display(/* color = */ WHITE, /* size = */ 1, /* x = */ 0, /* y = */ 0);
    display.print("Shutting Down in");
    
    setup_text_to_display(/* color = */ WHITE, /* size = */ 2, /* x = */ 0, /* y = */ 18);
    display.print(seconds);
    
    setup_text_to_display(/* color = */ WHITE, /* size = */ 1, /* x = */ 0, /* y = */ 44);
    display.print("seconds.");
    
    setup_text_to_display(/* color = */ WHITE, /* size = */ 2, /* x = */ 0, /* y = */ 56);
    if(tilt_enabled)
    {
      display.print("Shake dice to stop.");
    }
    else
    {
      display.print("Press any button to stop.");
    }
    display.display(); // write to display
  }

  if(millis() >= (last_activity + DEEP_SLEEP_AFTER_THIS_MANY_MS_OF_INACTIVITY))
  {
    digitalWrite(ROLL_LED_PIN, LOW);
    digitalWrite(DICE_LED_PIN, LOW);
    
    display.fillScreen(BLACK); // erase the whole display
    setup_text_to_display(/* color = */ WHITE, /* size = */ 1, /* x = */ 0, /* y = */ 0);
    display.print("Shutting Down");
    
    setup_text_to_display(/* color = */ WHITE, /* size = */ 2, /* x = */ 0, /* y = */ 24);
    display.print("Good Bye");
    display.display(); // write to display
    delay(1000);
    
    display.fillScreen(BLACK); // erase the whole display
    display.display(); // write to display
    
    //For this to work, connect D0 and RST pins with a jumper wire.
    Serial.println("Enter deep sleep mode");
    ESP.deepSleep(0, RF_DISABLED);
  }
}

void sleep_for_poll_rate()
{
  //Source: https://www.mischianti.org/2019/11/21/wemos-d1-mini-esp8266-the-three-type-of-sleep-mode-to-manage-energy-savings-part-4/
  
  //Serial.println("Enter light sleep mode");
  
  //light sleep config
  wifi_set_opmode(NULL_MODE);
  wifi_fpm_set_sleep_type(LIGHT_SLEEP_T);
  wifi_fpm_open();
  wifi_fpm_set_wakeup_cb(callback);
  wifi_fpm_do_sleep(HOW_FAST_BUTTONS_AND_SCREEN_ARE_PROCESSED_IN_MS *1000 );
  delay(HOW_FAST_BUTTONS_AND_SCREEN_ARE_PROCESSED_IN_MS + 1);

  //Serial.println("Exit light sleep mode");

  wifi_set_sleep_type(NONE_SLEEP_T);
}

void process_led_state()
{
  if (roll_flag || (tilt_flag && tilt_enabled))
  {
    digitalWrite(ROLL_LED_PIN, LOW);
  }
  else
  {
    digitalWrite(ROLL_LED_PIN, HIGH);
  }
  
  digitalWrite(DICE_LED_PIN, !digitalRead(button_pins[DIE_SELECT_BUTTON]));
}

ICACHE_RAM_ATTR void handle_tilt_interrupt()
{
  tilt_flag = true;
}


void enable_disable_tilt()
{
  tilt_enabled = !tilt_enabled;
  display.fillScreen(BLACK); // erase the whole display
  setup_text_to_display(/* color = */ WHITE, /* size = */ 1, /* x = */ 0, /* y = */ 0);
  display.print("Motion Roll");
  setup_text_to_display(/* color = */ WHITE, /* size = */ 1, /* x = */ 0, /* y = */ 12);
  if(tilt_enabled)
  {
    Serial.println("Tilt Enabled");
    display.print("Enabled");
    display.display(); // write to display
    delay(1000);
    display.setCursor(0,24);
    display.print("Shake upside down to roll");
    display.display(); // write to display
  }
  else
  {
    Serial.println("Tilt Disabled");
    display.print("Disabled");
    display.display(); // write to display
    delay(1000);
    display.setCursor(0,24);
    display.print("Press button to roll");
    display.display(); // write to display
  }
  delay(1000);
  display.fillScreen(BLACK);
  drawCurDie();
  drawDie();
  display.display();
}

void process_roll_request()
{
  display.fillScreen(BLACK); // erase the whole display
  display.setTextColor(WHITE);
  display.setTextSize(3);
  int roll;
  int roll2 = 0;
  
#ifdef USE_NEOPIXELS
  colorWipe(strip.Color(0, 0, 255), 50); // Blue
#endif
  
  if(die[curDie] != 7)
  {
    roll = random(1, die[curDie]+1); // store the random number
  }
  else 
  {
    roll = random(1, die[curDie]); // store the random number
    roll2 = random(1, die[curDie]);
  }
  
  
  if (roll < 10) 
  {
      // single character number
        switch(die[curDie])
        {
          case 2:
          case 4:
            display.setCursor(57, 29); 
            break;
          case 6:
            draw6(roll);
            break;
          case 7:
            draw7(roll, roll2);
            break;
          case 8:
          case 10:
          case 12:
            display.setCursor(57, 32); 
            break;
          case 20:
            display.setCursor(57, 22);
            break;
        }
      if((die[curDie] != 6) && (die[curDie] != 7)) 
      {
        display.println(roll); // write the roll
      }
      drawDie(); // draw the outline
      drawCurDie();
  }
  else 
  {
      // dual character number
        switch(die[curDie])
        {
          case 10:
          case 12:
            display.setCursor(47, 32); 
            break;
          case 20:
            display.setCursor(47, 22);
            break;
        }
      
      display.println(roll); // write the roll 
      drawDie(); // draw the outline
      drawCurDie();
  }
  
  display.display(); // write to display

#ifdef USE_NEOPIXELS
  if(die[curDie] != 7)
  {
    if ( roll == 1 ) {
      theaterChase(strip.Color(127,   0,   0), 50); // Red
    }
    else if ( roll == 20 ) {
      rainbowCycle(20);
    }
    else {
      colorWipe(strip.Color(0, 255, 0), 50); // Green
    }
  }else 
  {
    if ( roll + roll2 == 2 ) {
      theaterChase(strip.Color(127,   0,   0), 50); // Red
    }
    else {
      colorWipe(strip.Color(0, 255, 0), 50); // Green
    }
  }
#endif

}

void process_die_change_request()
{
  curDie++;
  if (curDie > 7)
  {
    curDie=0;
  }
  display.fillScreen(BLACK);
  drawCurDie();
  drawDie();
  display.display();
}

void drawDie() 
{

  switch(die[curDie])
  {
    case 2:
      display.drawCircle(SCREEN_WIDTH/2, 40, 23, SSD1306_WHITE);
      break;
    case 4:
      display.drawTriangle(40, 63, 88, 63, 64, 16, SSD1306_WHITE);
      break;
    case 6:
      display.drawRoundRect(40, 16, 48, 48, 5, WHITE);
      break;
    case 7:
      display.drawRoundRect(10, 16, 48, 48, 5, WHITE);
      display.drawRoundRect(70, 16, 48, 48, 5, WHITE);
      break;
    case 8:
      display.drawTriangle(40, 60, 88, 60, 64, 16, SSD1306_WHITE);
      display.drawTriangle(40, 60, 88, 60, 64, 80, SSD1306_WHITE);
      display.drawTriangle(40, 60, 64, 16, 40, 36, SSD1306_WHITE);
      display.drawTriangle(88, 60, 64, 16, 88, 36, SSD1306_WHITE);
      break;
    case 10:
      static const unsigned char PROGMEM d10[] =
      {
        0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xf8,0x1f,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xf8,0x0f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xf0,0x0f,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0xe0,0x07,0xbe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7d,0xe0,0x03,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xf3,0xc0,0x03,0xcf,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe7,0xc0,0x01,0xe7,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xc7,0x80,0x00,0xf3,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x8f,0x00,0x00,0xf1,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x0f,0x00,0x00,0x78,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x1e,0x00,0x00,0x7c,0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x3c,0x00,0x00,0x3c,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x3c,0x00,0x00,0x1e,0x0f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe0,0x78,0x00,0x00,0x1f,0x07,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xc0,0xf0,0x00,0x00,0x0f,0x03,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x80,0xf0,0x00,0x00,0x07,0x81,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x01,0xe0,0x00,0x00,0x07,0x80,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x03,0xe0,0x00,0x00,0x03,0xc0,0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x03,0xc0,0x00,0x00,0x01,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0x80,0x00,0x00,0x01,0xe0,0x0f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe0,0x0f,0x80,0x00,0x00,0x00,0xf0,0x07,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xc0,0x0f,0x00,0x00,0x00,0x00,0x78,0x03,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x80,0x1e,0x00,0x00,0x00,0x00,0x78,0x01,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x00,0x1e,0x00,0x00,0x00,0x00,0x3c,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x3c,0x00,0x00,0x00,0x00,0x3e,0x00,0x3e,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0x00,0x78,0x00,0x00,0x00,0x00,0x1e,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x00,0x78,0x00,0x00,0x00,0x00,0x0f,0x00,0x0f,0x80,0x00,0x00,0x00,0x00,0x03,0xe0,0x00,0xf0,0x00,0x00,0x00,0x00,0x0f,0x80,0x07,0xc0,0x00,0x00,0x00,0x00,0x07,0xc0,0x01,0xe0,0x00,0x00,0x00,0x00,0x07,0x80,0x03,0xe0,0x00,0x00,0x00,0x00,0x0f,0x80,0x01,0xe0,0x00,0x00,0x00,0x00,0x03,0xc0,0x01,0xf0,0x00,0x00,0x00,0x00,0x1f,0x00,0x03,0xc0,0x00,0x00,0x00,0x00,0x03,0xc0,0x00,0xf8,0x00,0x00,0x00,0x00,0x3e,0x00,0x07,0xc0,0x00,0x00,0x00,0x00,0x01,0xe0,0x00,0x3e,0x00,0x00,0x00,0x00,0x7c,0x00,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x1f,0x00,0x00,0x00,0x00,0xf8,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x0f,0x80,0x00,0x00,0x01,0xe0,0x00,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x07,0xc0,0x00,0x00,0x07,0xc0,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x03,0xe0,0x00,0x00,0x0f,0x80,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x01,0xf0,0x00,0x00,0x1f,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0xf8,0x00,0x00,0x3e,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x00,0x00,0x3e,0x00,0x00,0x7c,0x00,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x1f,0x00,0x00,0xf8,0x00,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x00,0x0f,0x80,0x01,0xf0,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xc0,0x00,0x07,0xc0,0x07,0xc0,0x00,0x1f,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xfc,0x00,0x03,0xe0,0x0f,0x80,0x01,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xff,0xc0,0x01,0xf0,0x1f,0x00,0x3f,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x03,0xff,0x7f,0xfe,0x00,0xf8,0x3e,0x07,0xff,0xe0,0x0f,0xfc,0x00,0x00,0x00,0x00,0x1f,0xf8,0x07,0xff,0xe0,0x3c,0x7c,0x7f,0xfe,0x00,0x01,0xff,0x80,0x00,0x00,0x00,0xff,0xc0,0x00,0x3f,0xff,0x1f,0xff,0xff,0xc0,0x00,0x00,0x3f,0xf0,0x00,0x00,0x0f,0xfc,0x00,0x00,0x03,0xff,0xff
      };
      display.drawBitmap(0, 16, d10, 128, 48, 1);
      break;
    case 12:
      display.drawLine(45, 63, 83, 63, SSD1306_WHITE);
      display.drawLine(45, 63, 35, 36, SSD1306_WHITE);
      display.drawLine(35, 36, 64, 16, SSD1306_WHITE);
      display.drawLine(64, 16, 93, 36, SSD1306_WHITE);
      display.drawLine(93, 36, 83, 63, SSD1306_WHITE);
      break;
    case 20:
      static const unsigned char PROGMEM d20[] =
      {
        0x38,0x00,0x3f,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xfc,0x00,0x1c,0x38,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x1c,0x38,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x1c,0x38,0x00,0x03,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xc0,0x00,0x1c,0x38,0x00,0x03,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xc0,0x00,0x1c,0x38,0x00,0x07,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xe0,0x00,0x1c,0x38,0x00,0x07,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0xe0,0x00,0x1c,0x38,0x00,0x0f,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0xf0,0x00,0x1c,0x38,0x00,0x0e,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x70,0x00,0x1c,0x38,0x00,0x1e,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x78,0x00,0x1c,0x38,0x00,0x1c,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x38,0x00,0x1c,0x38,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0x3c,0x00,0x1c,0x38,0x00,0x38,0x03,0xc0,0x00,0x00,0x00,0x00,0x00,0x03,0xc0,0x1c,0x00,0x1c,0x38,0x00,0x38,0x01,0xc0,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x1e,0x00,0x1c,0x38,0x00,0x78,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x0e,0x00,0x1c,0x38,0x00,0x70,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x0f,0x00,0x1c,0x38,0x00,0xf0,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x0e,0x00,0x07,0x00,0x1c,0x38,0x00,0xe0,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x07,0x80,0x1c,0x38,0x01,0xe0,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x03,0x80,0x1c,0x38,0x01,0xc0,0x00,0x1c,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x03,0x80,0x1c,0x38,0x03,0xc0,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x03,0xc0,0x1c,0x38,0x03,0x80,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x01,0xc0,0x1c,0x38,0x07,0x80,0x00,0x07,0x00,0x00,0x00,0x00,0x01,0xe0,0x00,0x01,0xe0,0x1c,0x38,0x07,0x00,0x00,0x07,0x80,0x00,0x00,0x00,0x01,0xc0,0x00,0x00,0xe0,0x1c,0x38,0x0f,0x00,0x00,0x03,0xc0,0x00,0x00,0x00,0x03,0xc0,0x00,0x00,0xf0,0x1c,0x38,0x0e,0x00,0x00,0x03,0xc0,0x00,0x00,0x00,0x07,0x80,0x00,0x00,0x70,0x1c,0x38,0x1e,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x78,0x1c,0x38,0x1c,0x00,0x00,0x00,0xf0,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x38,0x1c,0x38,0x3c,0x00,0x00,0x00,0xf0,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x3c,0x1c,0x38,0x38,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,0x1c,0x1c,0x38,0x78,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x1e,0x1c,0x38,0x70,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x0e,0x1c,0x38,0xf0,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x0f,0x1c,0x38,0xe0,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0xf0,0x00,0x00,0x00,0x07,0x1c,0x39,0xe0,0x00,0x00,0x00,0x0f,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x07,0x9c,0x39,0xc0,0x00,0x00,0x00,0x07,0x80,0x00,0x01,0xc0,0x00,0x00,0x00,0x03,0x9c,0x39,0xc0,0x00,0x00,0x00,0x03,0xc0,0x00,0x03,0xc0,0x00,0x00,0x00,0x03,0xdc,0x3b,0xc0,0x00,0x00,0x00,0x03,0xc0,0x00,0x07,0x80,0x00,0x00,0x00,0x01,0xdc,0x3b,0x80,0x00,0x00,0x00,0x01,0xe0,0x00,0x0f,0x00,0x00,0x00,0x00,0x01,0xfc,0x3f,0x80,0x00,0x00,0x00,0x00,0xe0,0x00,0x0e,0x00,0x00,0x00,0x00,0x00,0xfc,0x3f,0x00,0x00,0x00,0x00,0x00,0xf0,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0xfc,0x3f,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x7c,0x3e,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x7c,0x3e,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x7c,0x3c,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0xf0,0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x00,0x00,0x00,0x00,0x00,0x0e,0x00,0xe0,0x00,0x00,0x00,0x00,0x00,0x3c,0x3f,0xe0,0x00,0x00,0x00,0x00,0x0f,0x01,0xe0,0x00,0x00,0x00,0x00,0x07,0xfc,0x3f,0xff,0xc0,0x00,0x00,0x00,0x07,0x83,0xc0,0x00,0x00,0x00,0x07,0xff,0xfc
      };
      display.drawBitmap(4, 16, d20, 120, 48, 1);
      break;
  }

    // display.drawLine(x1, y1, x2, y2, SSD1306_WHITE);
} //end drawDie

void drawCurDie()
{
  setup_text_to_display(/* color = */ WHITE, /* size = */ 2, /* x = */ 2, /* y = */ 0);
  if(die[curDie] == 2)
  {
    display.print("Coin:");
  } else 
  {
    display.print("Die:"); 
  }
  if( die[curDie] != 7)
  {
    display.print(die[curDie]);
  }
  else
  {
    display.print("6x2");
  }
  
  display.setTextSize(1);
  display.println(" sides");
} //end drawCurDie

void draw6(int roll)
{
  switch(roll)
  {
    case 1:
      display.fillCircle(display.width() / 2, 40, 5, SSD1306_WHITE);
      break;
    case 2:
      display.fillCircle(display.width() / 2-15, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 25, 5, SSD1306_WHITE);
      break;
    case 3:
      display.fillCircle(display.width() / 2, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 25, 5, SSD1306_WHITE);
      break;
    case 4:
      display.fillCircle(display.width() / 2-15, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 55, 5, SSD1306_WHITE);
      break;
    case 5:
      display.fillCircle(display.width() / 2, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 55, 5, SSD1306_WHITE);
      break;
    case 6:
      display.fillCircle(display.width() / 2-15, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15, 55, 5, SSD1306_WHITE);
      break;
  }//end roll
}// end of draw6

void draw7(int roll, int roll2)
{
  switch(roll)
  {
    case 1:
      display.fillCircle(display.width() / 2-30, 40, 5, SSD1306_WHITE);
      break;
    case 2:
      display.fillCircle(display.width() / 2-15-30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 25, 5, SSD1306_WHITE);
      break;
    case 3:
      display.fillCircle(display.width() / 2-30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15-30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 25, 5, SSD1306_WHITE);
      break;
    case 4:
      display.fillCircle(display.width() / 2-15-30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15-30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 55, 5, SSD1306_WHITE);
      break;
    case 5:
      display.fillCircle(display.width() / 2-30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15-30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15-30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 55, 5, SSD1306_WHITE);
      break;
    case 6:
      display.fillCircle(display.width() / 2-15-30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15-30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15-30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15-30, 55, 5, SSD1306_WHITE);
      break;
  }//end roll

    switch(roll2)
    {
    case 1:
      display.fillCircle(display.width() / 2+30, 40, 5, SSD1306_WHITE);
      break;
    case 2:
      display.fillCircle(display.width() / 2-15+30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 25, 5, SSD1306_WHITE);
      break;
    case 3:
      display.fillCircle(display.width() / 2+30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15+30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 25, 5, SSD1306_WHITE);
      break;
    case 4:
      display.fillCircle(display.width() / 2-15+30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15+30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 55, 5, SSD1306_WHITE);
      break;
    case 5:
      display.fillCircle(display.width() / 2+30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15+30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15+30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 55, 5, SSD1306_WHITE);
      break;
    case 6:
      display.fillCircle(display.width() / 2-15+30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 40, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15+30, 55, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2-15+30, 25, 5, SSD1306_WHITE);
      display.fillCircle(display.width() / 2+15+30, 55, 5, SSD1306_WHITE);
      break;
  }//end roll
}// end draw7

void display_voltage()
{
  const float battery_max = 4.20; //maximum voltage of battery
  const float battery_min = 3.0;  //minimum voltage of battery before shutdown
  
  while(button_state[DIE_SELECT_BUTTON] == IS_HELD)
  {
#ifdef USE_BATTERY
    float raw = analogRead(BATTERY_MONITOR_PIN);
    float volts = raw / 1023 * 4.5;
    float percent = ((volts - battery_min) / (battery_max - battery_min)) * 100;
#else
    float raw = ESP.getVcc();
    float volts = raw / 1000;
#endif
    
    display.fillScreen(BLACK); // erase the whole display
    setup_text_to_display(/* color = */ WHITE, /* size = */ 1, /* x = */ 0, /* y = */ 0);
    display.print("Battery Voltage:");
    
    setup_text_to_display(/* color = */ WHITE, /* size = */ 2, /* x = */ 0, /* y = */ 24);
    Serial.printf("The internal VCC reads %1.2f volts\n", volts);
    display.printf("%1.2f volts\n", volts);
    
#ifdef USE_BATTERY
    display.setCursor(0,50);
    display.printf("%1.0f %%\n", percent);
#endif
    
    display.display(); // write to display

    poll_input_signals();
    ESP.wdtFeed();
    check_for_inactivity_then_power_down(); //if user holds button too long, turn off
    sleep_for_poll_rate();
  }

  //go back to main screen
  display.fillScreen(BLACK);
  drawCurDie();
  drawDie();
  display.display();
}

//--------------------------------------
//          Button Subroutines         |
//--------------------------------------

void process_button_presses()
{
  for(byte i=0; i < NUMBER_OF_BUTTONS; i++)
  {
    if(button_state[i] == WAS_RELEASED)
    {
        //CLICKED ACTION

        //Note: action taken on WAS_RELEASED instead of IS_PRESSED to prevent extra clicks during button holds

        last_interaction_timestamp[i] = millis();

        if(last_mode_button_state[i] == NOT_PROCESSED)
        {
            activity_flag = true;
            
            //one action per press / hold for all buttons
            for(byte j=0; j < NUMBER_OF_BUTTONS; j++)
            {
              last_mode_button_state[j] = PROCESSED;
            }

            //button was clicked
            switch(i)
            {
              case TILT_INPUT_1:
              case TILT_INPUT_2:
                Serial.println("Tilt");
                tilt_flag = true;
                break;
              case ROLL_BUTTON:
                roll_flag = true;
                break;
              case DIE_SELECT_BUTTON:
                process_die_change_request();
                break;
              default:
                Serial.print("Unknown button press: ");
                Serial.println(i);
                break;
            }
        }
    }
    else if ( ( button_state[i] == IS_HELD ) &&
              ( last_interaction_timestamp[i] + BUTTON_HOLD_DELAY_IN_MILLIS_UNTIL_HELD_ACTION < millis() ) )
    {
        //HELD ACTION

        last_interaction_timestamp[i] = millis();

        if(last_mode_button_state[i] == NOT_PROCESSED)
        {
            activity_flag = true;
            
            //one action per press / hold for all buttons
            for(byte j=0; j < NUMBER_OF_BUTTONS; j++)
            {
              last_mode_button_state[j] = PROCESSED;
            }

            //button was held
            switch(i)
            {
              case ROLL_BUTTON:
                enable_disable_tilt();
                break;
              case TILT_INPUT_1:
              case TILT_INPUT_2:
                //TBD
                break;
              case DIE_SELECT_BUTTON:
                //show battery voltage
                display_voltage();
                break;
              default:
                Serial.print("Unknown button press: ");
                Serial.println(i);
                break;
            }
        }
    }
    else if (button_state[i] == IS_NOT_PRESSED)
    {
        //reset timers
        last_interaction_timestamp[i] = millis();
        last_mode_button_state[i] = NOT_PROCESSED;
    }

  }// end for loop
}

void poll_input_signals()
{
    for(byte i=0; i < NUMBER_OF_BUTTONS; i++)
    {
        if( button_types[i] == ACTIVE_HIGH )
        {
            /* read digital active high beam signal */
            current_button_read[i] = digitalRead(button_pins[i]);
        }
        else if( button_types[i] == ANALOG_THRESHOLD )
        {
            /* read analog input, active high */
            //current_button_read[i] = get_analog_signal_as_bool(i);
        }
        else // button_types[i] == ACTIVE_LOW
        {
            /* read digital active low button signal */
            current_button_read[i] = !digitalRead(button_pins[i]);
        }
        
        if (!last_button_read[i] && current_button_read[i])
        {
            //button was just pressed
            button_state[i] = IS_PRESSED;
            //Serial.print("Button ");
            //Serial.print(i);
            //Serial.println(" was pressed.");
        }
        else if  (last_button_read[i] && current_button_read[i])
        {
            button_state[i] = IS_HELD;
            //Serial.print("Button ");
            //Serial.print(i);
            //Serial.println(" is held.");
        }
        else if (last_button_read[i] && !current_button_read[i])
        {
            //button was just released
            button_state[i] = WAS_RELEASED;
            //Serial.print("Button ");
            //Serial.print(i);
            //Serial.println(" was released.");
        }
        else
        {
            button_state[i] = IS_NOT_PRESSED;
        }

        last_button_read[i] = current_button_read[i];
    }
}

//--------------------------------------
//        Neopixel Subroutines         |
//--------------------------------------

#ifdef USE_NEOPIXELS
// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
      strip.setPixelColor(i, c);
      strip.show();
      delay(wait);
  }
}

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
    for(i=0; i< strip.numPixels(); i++) {
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
    }
    strip.show();
    delay(wait);
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3; q++) {
      for (int i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, c);    //turn every third pixel on
      }
      strip.show();

      delay(wait);

      for (int i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
    }
  }
}

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  if(WheelPos < 85) {
   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
  } else if(WheelPos < 170) {
   WheelPos -= 85;
   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
  } else {
   WheelPos -= 170;
   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
}
#endif
